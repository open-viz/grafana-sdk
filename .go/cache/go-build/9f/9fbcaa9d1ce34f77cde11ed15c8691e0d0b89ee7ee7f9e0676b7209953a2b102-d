// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/local/go/src/os/user/cgo_lookup_unix.go:1:1
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build (aix || darwin || dragonfly || freebsd || (!android && linux) || netbsd || openbsd || solaris) && cgo && !osusergo
// +build aix darwin dragonfly freebsd !android,linux netbsd openbsd solaris
// +build cgo
// +build !osusergo

package user; import _cgo_unsafe "unsafe"

import (
	"fmt"
	"strconv"
	"strings"
	"syscall"
	"unsafe"
)

/*
#cgo solaris CFLAGS: -D_POSIX_PTHREAD_SEMANTICS
#include <unistd.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>
#include <stdlib.h>

static int mygetpwuid_r(int uid, struct passwd *pwd,
	char *buf, size_t buflen, struct passwd **result) {
	return getpwuid_r(uid, pwd, buf, buflen, result);
}

static int mygetpwnam_r(const char *name, struct passwd *pwd,
	char *buf, size_t buflen, struct passwd **result) {
	return getpwnam_r(name, pwd, buf, buflen, result);
}

static int mygetgrgid_r(int gid, struct group *grp,
	char *buf, size_t buflen, struct group **result) {
 return getgrgid_r(gid, grp, buf, buflen, result);
}

static int mygetgrnam_r(const char *name, struct group *grp,
	char *buf, size_t buflen, struct group **result) {
 return getgrnam_r(name, grp, buf, buflen, result);
}
*/
import _ "unsafe"

func current() (*User, error) {
	return lookupUnixUid(syscall.Getuid())
}

func lookupUser(username string) (*User, error) {
	var pwd  /*line :55:10*/_Ctype_struct_passwd /*line :55:25*/
	var result * /*line :56:14*/_Ctype_struct_passwd /*line :56:29*/
	nameC := make([]byte, len(username)+1)
	copy(nameC, username)

	buf := alloc(userBuffer)
	defer buf.free()

	err := retryWithBuffer(buf, func() syscall.Errno {
		// mygetpwnam_r is a wrapper around getpwnam_r to avoid
		// passing a size_t to getpwnam_r, because for unknown
		// reasons passing a size_t to getpwnam_r doesn't work on
		// Solaris.
		return syscall.Errno(func() _Ctype_int{ var _cgo0 *_Ctype_char = /*line :68:39*/(*_Ctype_char /*line :68:47*/)(unsafe.Pointer(&nameC[0])); _cgoBase1 := /*line :69:4*/&pwd; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_char = /*line :70:4*/(*_Ctype_char /*line :70:12*/)(buf.ptr); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :71:12*/(buf.size); _cgoBase4 := /*line :72:4*/&result; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return _Cfunc_mygetpwnam_r(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }())
	})
	if err != nil {
		return nil, fmt.Errorf("user: lookup username %s: %v", username, err)
	}
	if result == nil {
		return nil, UnknownUserError(username)
	}
	return buildUser(&pwd), err
}

func lookupUserId(uid string) (*User, error) {
	i, e := strconv.Atoi(uid)
	if e != nil {
		return nil, e
	}
	return lookupUnixUid(i)
}

func lookupUnixUid(uid int) (*User, error) {
	var pwd  /*line :92:10*/_Ctype_struct_passwd /*line :92:25*/
	var result * /*line :93:14*/_Ctype_struct_passwd /*line :93:29*/

	buf := alloc(userBuffer)
	defer buf.free()

	err := retryWithBuffer(buf, func() syscall.Errno {
		// mygetpwuid_r is a wrapper around getpwuid_r to avoid using uid_t
		// because C.uid_t(uid) for unknown reasons doesn't work on linux.
		return syscall.Errno(func() _Ctype_int{ var _cgo0 _Ctype_int = _Ctype_int /*line :101:44*/(uid); _cgoBase1 := /*line :102:4*/&pwd; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_char = /*line :103:4*/(*_Ctype_char /*line :103:12*/)(buf.ptr); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :104:12*/(buf.size); _cgoBase4 := /*line :105:4*/&result; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return _Cfunc_mygetpwuid_r(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }())
	})
	if err != nil {
		return nil, fmt.Errorf("user: lookup userid %d: %v", uid, err)
	}
	if result == nil {
		return nil, UnknownUserIdError(uid)
	}
	return buildUser(&pwd), nil
}

func buildUser(pwd * /*line :116:21*/_Ctype_struct_passwd /*line :116:36*/) *User {
	u := &User{
		Uid:      strconv.FormatUint(uint64(pwd.pw_uid), 10),
		Gid:      strconv.FormatUint(uint64(pwd.pw_gid), 10),
		Username: ( /*line :120:13*/_Cfunc_GoString /*line :120:22*/)(pwd.pw_name),
		Name:     ( /*line :121:13*/_Cfunc_GoString /*line :121:22*/)(pwd.pw_gecos),
		HomeDir:  ( /*line :122:13*/_Cfunc_GoString /*line :122:22*/)(pwd.pw_dir),
	}
	// The pw_gecos field isn't quite standardized. Some docs
	// say: "It is expected to be a comma separated list of
	// personal data where the first item is the full name of the
	// user."
	if i := strings.Index(u.Name, ","); i >= 0 {
		u.Name = u.Name[:i]
	}
	return u
}

func lookupGroup(groupname string) (*Group, error) {
	var grp  /*line :135:10*/_Ctype_struct_group /*line :135:24*/
	var result * /*line :136:14*/_Ctype_struct_group /*line :136:28*/

	buf := alloc(groupBuffer)
	defer buf.free()
	cname := make([]byte, len(groupname)+1)
	copy(cname, groupname)

	err := retryWithBuffer(buf, func() syscall.Errno {
		return syscall.Errno(func() _Ctype_int{ var _cgo0 *_Ctype_char = /*line :144:39*/(*_Ctype_char /*line :144:47*/)(unsafe.Pointer(&cname[0])); _cgoBase1 := /*line :145:4*/&grp; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_char = /*line :146:4*/(*_Ctype_char /*line :146:12*/)(buf.ptr); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :147:12*/(buf.size); _cgoBase4 := /*line :148:4*/&result; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return _Cfunc_mygetgrnam_r(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }())
	})
	if err != nil {
		return nil, fmt.Errorf("user: lookup groupname %s: %v", groupname, err)
	}
	if result == nil {
		return nil, UnknownGroupError(groupname)
	}
	return buildGroup(&grp), nil
}

func lookupGroupId(gid string) (*Group, error) {
	i, e := strconv.Atoi(gid)
	if e != nil {
		return nil, e
	}
	return lookupUnixGid(i)
}

func lookupUnixGid(gid int) (*Group, error) {
	var grp  /*line :168:10*/_Ctype_struct_group /*line :168:24*/
	var result * /*line :169:14*/_Ctype_struct_group /*line :169:28*/

	buf := alloc(groupBuffer)
	defer buf.free()

	err := retryWithBuffer(buf, func() syscall.Errno {
		// mygetgrgid_r is a wrapper around getgrgid_r to avoid using gid_t
		// because C.gid_t(gid) for unknown reasons doesn't work on linux.
		return syscall.Errno(func() _Ctype_int{ var _cgo0 _Ctype_int = _Ctype_int /*line :177:44*/(gid); _cgoBase1 := /*line :178:4*/&grp; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_char = /*line :179:4*/(*_Ctype_char /*line :179:12*/)(buf.ptr); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :180:12*/(buf.size); _cgoBase4 := /*line :181:4*/&result; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return _Cfunc_mygetgrgid_r(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }())
	})
	if err != nil {
		return nil, fmt.Errorf("user: lookup groupid %d: %v", gid, err)
	}
	if result == nil {
		return nil, UnknownGroupIdError(strconv.Itoa(gid))
	}
	return buildGroup(&grp), nil
}

func buildGroup(grp * /*line :192:22*/_Ctype_struct_group /*line :192:36*/) *Group {
	g := &Group{
		Gid:  strconv.Itoa(int(grp.gr_gid)),
		Name: ( /*line :195:9*/_Cfunc_GoString /*line :195:18*/)(grp.gr_name),
	}
	return g
}

type bufferKind  /*line :200:17*/_Ctype_int /*line :200:22*/

const (
	userBuffer  = bufferKind(( /*line :203:27*/_Ciconst__SC_GETPW_R_SIZE_MAX /*line :203:48*/))
	groupBuffer = bufferKind(( /*line :204:27*/_Ciconst__SC_GETGR_R_SIZE_MAX /*line :204:48*/))
)

func (k bufferKind) initialSize()  /*line :207:35*/_Ctype_size_t /*line :207:43*/ {
	sz := ( /*line :208:8*/_Cfunc_sysconf /*line :208:16*/)( /*line :208:18*/_Ctype_int /*line :208:23*/(k))
	if sz == -1 {
		// DragonFly and FreeBSD do not have _SC_GETPW_R_SIZE_MAX.
		// Additionally, not all Linux systems have it, either. For
		// example, the musl libc returns -1.
		return 1024
	}
	if !isSizeReasonable(int64(sz)) {
		// Truncate.  If this truly isn't enough, retryWithBuffer will error on the first run.
		return maxBufferSize
	}
	return  /*line :219:9*/_Ctype_size_t /*line :219:17*/(sz)
}

type memBuffer struct {
	ptr  unsafe.Pointer
	size  /*line :224:7*/_Ctype_size_t /*line :224:15*/
}

func alloc(kind bufferKind) *memBuffer {
	sz := kind.initialSize()
	return &memBuffer{
		ptr:  ( /*line :230:9*/_Cfunc__CMalloc /*line :230:16*/)(sz),
		size: sz,
	}
}

func (mb *memBuffer) resize(newSize  /*line :235:37*/_Ctype_size_t /*line :235:45*/) {
	mb.ptr = func() _cgo_unsafe.Pointer{ _cgo0 := /*line :236:21*/mb.ptr; var _cgo1 _Ctype_size_t = /*line :236:29*/newSize; _cgoCheckPointer(_cgo0, nil); return _Cfunc_realloc(_cgo0, _cgo1); }()
	mb.size = newSize
}

func (mb *memBuffer) free() {
	func() { _cgo0 := /*line :241:9*/mb.ptr; _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
}

// retryWithBuffer repeatedly calls f(), increasing the size of the
// buffer each time, until f succeeds, fails with a non-ERANGE error,
// or the buffer exceeds a reasonable limit.
func retryWithBuffer(buf *memBuffer, f func() syscall.Errno) error {
	for {
		errno := f()
		if errno == 0 {
			return nil
		} else if errno != syscall.ERANGE {
			return errno
		}
		newSize := buf.size * 2
		if !isSizeReasonable(int64(newSize)) {
			return fmt.Errorf("internal buffer exceeds %d bytes", maxBufferSize)
		}
		buf.resize(newSize)
	}
}

const maxBufferSize = 1 << 20

func isSizeReasonable(sz int64) bool {
	return sz > 0 && sz <= maxBufferSize
}

// Because we can't use cgo in tests:
func structPasswdForNegativeTest()  /*line :270:36*/_Ctype_struct_passwd /*line :270:51*/ {
	sp :=  /*line :271:8*/_Ctype_struct_passwd /*line :271:23*/{}
	sp.pw_uid = 1<<32 - 2
	sp.pw_gid = 1<<32 - 3
	return sp
}
