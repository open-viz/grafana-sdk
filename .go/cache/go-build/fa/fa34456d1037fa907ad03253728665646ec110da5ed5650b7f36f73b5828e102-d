// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/local/go/src/net/cgo_unix.go:1:1
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build cgo && !netgo && (aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris)
// +build cgo
// +build !netgo
// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris

package net

/*
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <string.h>

// If nothing else defined EAI_OVERFLOW, make sure it has a value.
#ifndef EAI_OVERFLOW
#define EAI_OVERFLOW -12
#endif
*/
import _ "unsafe"

import (
	"context"
	"syscall"
	"unsafe"
)

// An addrinfoErrno represents a getaddrinfo, getnameinfo-specific
// error number. It's a signed number and a zero value is a non-error
// by convention.
type addrinfoErrno int

func (eai addrinfoErrno) Error() string   { return ( /*line :38:52*/_Cfunc_GoString /*line :38:61*/)(( /*line :38:63*/_Cfunc_gai_strerror /*line :38:76*/)( /*line :38:78*/_Ctype_int /*line :38:83*/(eai))) }
func (eai addrinfoErrno) Temporary() bool { return eai == ( /*line :39:59*/_Ciconst_EAI_AGAIN /*line :39:69*/) }
func (eai addrinfoErrno) Timeout() bool   { return false }

type portLookupResult struct {
	port int
	err  error
}

type ipLookupResult struct {
	addrs []IPAddr
	cname string
	err   error
}

type reverseLookupResult struct {
	names []string
	err   error
}

func cgoLookupHost(ctx context.Context, name string) (hosts []string, err error, completed bool) {
	addrs, err, completed := cgoLookupIP(ctx, "ip", name)
	for _, addr := range addrs {
		hosts = append(hosts, addr.String())
	}
	return
}

func cgoLookupPort(ctx context.Context, network, service string) (port int, err error, completed bool) {
	var hints  /*line :67:12*/_Ctype_struct_addrinfo /*line :67:29*/
	switch network {
	case "": // no hints
	case "tcp", "tcp4", "tcp6":
		hints.ai_socktype = ( /*line :71:23*/_Ciconst_SOCK_STREAM /*line :71:35*/)
		hints.ai_protocol = ( /*line :72:23*/_Ciconst_IPPROTO_TCP /*line :72:35*/)
	case "udp", "udp4", "udp6":
		hints.ai_socktype = ( /*line :74:23*/_Ciconst_SOCK_DGRAM /*line :74:34*/)
		hints.ai_protocol = ( /*line :75:23*/_Ciconst_IPPROTO_UDP /*line :75:35*/)
	default:
		return 0, &DNSError{Err: "unknown network", Name: network + "/" + service}, true
	}
	switch ipVersion(network) {
	case '4':
		hints.ai_family = ( /*line :81:21*/_Ciconst_AF_INET /*line :81:29*/)
	case '6':
		hints.ai_family = ( /*line :83:21*/_Ciconst_AF_INET6 /*line :83:30*/)
	}
	if ctx.Done() == nil {
		port, err := cgoLookupServicePort(&hints, network, service)
		return port, err, true
	}
	result := make(chan portLookupResult, 1)
	go cgoPortLookup(result, &hints, network, service)
	select {
	case r := <-result:
		return r.port, r.err, true
	case <-ctx.Done():
		// Since there isn't a portable way to cancel the lookup,
		// we just let it finish and write to the buffered channel.
		return 0, mapErr(ctx.Err()), false
	}
}

func cgoLookupServicePort(hints * /*line :101:34*/_Ctype_struct_addrinfo /*line :101:51*/, network, service string) (port int, err error) {
	cservice := make([]byte, len(service)+1)
	copy(cservice, service)
	// Lowercase the C service name.
	for i, b := range cservice[:len(service)] {
		cservice[i] = lowerASCII(b)
	}
	var res * /*line :108:11*/_Ctype_struct_addrinfo /*line :108:28*/
	gerrno, err := func() (_Ctype_int, error){ var _cgo0 *_Ctype_char = /*line :109:31*/nil; var _cgo1 *_Ctype_char = /*line :109:36*/(*_Ctype_char /*line :109:44*/)(unsafe.Pointer(&cservice[0])); _cgo2 := /*line :109:77*/hints; _cgoBase3 := /*line :109:84*/&res; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return _C2func_getaddrinfo(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if gerrno != 0 {
		isTemporary := false
		switch gerrno {
		case ( /*line :113:8*/_Ciconst_EAI_SYSTEM /*line :113:19*/):
			if err == nil { // see golang.org/issue/6232
				err = syscall.EMFILE
			}
		default:
			err = addrinfoErrno(gerrno)
			isTemporary = addrinfoErrno(gerrno).Temporary()
		}
		return 0, &DNSError{Err: err.Error(), Name: network + "/" + service, IsTemporary: isTemporary}
	}
	defer func() func() { _cgo0 := /*line :123:23*/res; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_freeaddrinfo(_cgo0); }}()()

	for r := res; r != nil; r = r.ai_next {
		switch r.ai_family {
		case ( /*line :127:8*/_Ciconst_AF_INET /*line :127:16*/):
			sa := (*syscall.RawSockaddrInet4)(unsafe.Pointer(r.ai_addr))
			p := (*[2]byte)(unsafe.Pointer(&sa.Port))
			return int(p[0])<<8 | int(p[1]), nil
		case ( /*line :131:8*/_Ciconst_AF_INET6 /*line :131:17*/):
			sa := (*syscall.RawSockaddrInet6)(unsafe.Pointer(r.ai_addr))
			p := (*[2]byte)(unsafe.Pointer(&sa.Port))
			return int(p[0])<<8 | int(p[1]), nil
		}
	}
	return 0, &DNSError{Err: "unknown port", Name: network + "/" + service}
}

func cgoPortLookup(result chan<- portLookupResult, hints * /*line :140:59*/_Ctype_struct_addrinfo /*line :140:76*/, network, service string) {
	port, err := cgoLookupServicePort(hints, network, service)
	result <- portLookupResult{port, err}
}

func cgoLookupIPCNAME(network, name string) (addrs []IPAddr, cname string, err error) {
	acquireThread()
	defer releaseThread()

	var hints  /*line :149:12*/_Ctype_struct_addrinfo /*line :149:29*/
	hints.ai_flags = cgoAddrInfoFlags
	hints.ai_socktype = ( /*line :151:22*/_Ciconst_SOCK_STREAM /*line :151:34*/)
	hints.ai_family = ( /*line :152:20*/_Ciconst_AF_UNSPEC /*line :152:30*/)
	switch ipVersion(network) {
	case '4':
		hints.ai_family = ( /*line :155:21*/_Ciconst_AF_INET /*line :155:29*/)
	case '6':
		hints.ai_family = ( /*line :157:21*/_Ciconst_AF_INET6 /*line :157:30*/)
	}

	h := make([]byte, len(name)+1)
	copy(h, name)
	var res * /*line :162:11*/_Ctype_struct_addrinfo /*line :162:28*/
	gerrno, err := func() (_Ctype_int, error){ var _cgo0 *_Ctype_char = /*line :163:31*/(*_Ctype_char /*line :163:39*/)(unsafe.Pointer(&h[0])); var _cgo1 *_Ctype_char = /*line :163:65*/nil; _cgoBase2 := /*line :163:70*/&hints; _cgo2 := _cgoBase2; _cgoBase3 := /*line :163:78*/&res; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return _C2func_getaddrinfo(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if gerrno != 0 {
		isErrorNoSuchHost := false
		isTemporary := false
		switch gerrno {
		case ( /*line :168:8*/_Ciconst_EAI_SYSTEM /*line :168:19*/):
			if err == nil {
				// err should not be nil, but sometimes getaddrinfo returns
				// gerrno == C.EAI_SYSTEM with err == nil on Linux.
				// The report claims that it happens when we have too many
				// open files, so use syscall.EMFILE (too many open files in system).
				// Most system calls would return ENFILE (too many open files),
				// so at the least EMFILE should be easy to recognize if this
				// comes up again. golang.org/issue/6232.
				err = syscall.EMFILE
			}
		case ( /*line :179:8*/_Ciconst_EAI_NONAME /*line :179:19*/):
			err = errNoSuchHost
			isErrorNoSuchHost = true
		default:
			err = addrinfoErrno(gerrno)
			isTemporary = addrinfoErrno(gerrno).Temporary()
		}

		return nil, "", &DNSError{Err: err.Error(), Name: name, IsNotFound: isErrorNoSuchHost, IsTemporary: isTemporary}
	}
	defer func() func() { _cgo0 := /*line :189:23*/res; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_freeaddrinfo(_cgo0); }}()()

	if res != nil {
		cname = ( /*line :192:11*/_Cfunc_GoString /*line :192:20*/)(res.ai_canonname)
		if cname == "" {
			cname = name
		}
		if len(cname) > 0 && cname[len(cname)-1] != '.' {
			cname += "."
		}
	}
	for r := res; r != nil; r = r.ai_next {
		// We only asked for SOCK_STREAM, but check anyhow.
		if r.ai_socktype != ( /*line :202:23*/_Ciconst_SOCK_STREAM /*line :202:35*/) {
			continue
		}
		switch r.ai_family {
		case ( /*line :206:8*/_Ciconst_AF_INET /*line :206:16*/):
			sa := (*syscall.RawSockaddrInet4)(unsafe.Pointer(r.ai_addr))
			addr := IPAddr{IP: copyIP(sa.Addr[:])}
			addrs = append(addrs, addr)
		case ( /*line :210:8*/_Ciconst_AF_INET6 /*line :210:17*/):
			sa := (*syscall.RawSockaddrInet6)(unsafe.Pointer(r.ai_addr))
			addr := IPAddr{IP: copyIP(sa.Addr[:]), Zone: zoneCache.name(int(sa.Scope_id))}
			addrs = append(addrs, addr)
		}
	}
	return addrs, cname, nil
}

func cgoIPLookup(result chan<- ipLookupResult, network, name string) {
	addrs, cname, err := cgoLookupIPCNAME(network, name)
	result <- ipLookupResult{addrs, cname, err}
}

func cgoLookupIP(ctx context.Context, network, name string) (addrs []IPAddr, err error, completed bool) {
	if ctx.Done() == nil {
		addrs, _, err = cgoLookupIPCNAME(network, name)
		return addrs, err, true
	}
	result := make(chan ipLookupResult, 1)
	go cgoIPLookup(result, network, name)
	select {
	case r := <-result:
		return r.addrs, r.err, true
	case <-ctx.Done():
		return nil, mapErr(ctx.Err()), false
	}
}

func cgoLookupCNAME(ctx context.Context, name string) (cname string, err error, completed bool) {
	if ctx.Done() == nil {
		_, cname, err = cgoLookupIPCNAME("ip", name)
		return cname, err, true
	}
	result := make(chan ipLookupResult, 1)
	go cgoIPLookup(result, "ip", name)
	select {
	case r := <-result:
		return r.cname, r.err, true
	case <-ctx.Done():
		return "", mapErr(ctx.Err()), false
	}
}

// These are roughly enough for the following:
//
// Source		Encoding			Maximum length of single name entry
// Unicast DNS		ASCII or			<=253 + a NUL terminator
//			Unicode in RFC 5892		252 * total number of labels + delimiters + a NUL terminator
// Multicast DNS	UTF-8 in RFC 5198 or		<=253 + a NUL terminator
//			the same as unicast DNS ASCII	<=253 + a NUL terminator
// Local database	various				depends on implementation
const (
	nameinfoLen    = 64
	maxNameinfoLen = 4096
)

func cgoLookupPTR(ctx context.Context, addr string) (names []string, err error, completed bool) {
	var zone string
	ip := parseIPv4(addr)
	if ip == nil {
		ip, zone = parseIPv6Zone(addr)
	}
	if ip == nil {
		return nil, &DNSError{Err: "invalid address", Name: addr}, true
	}
	sa, salen := cgoSockaddr(ip, zone)
	if sa == nil {
		return nil, &DNSError{Err: "invalid address " + ip.String(), Name: addr}, true
	}
	if ctx.Done() == nil {
		names, err := cgoLookupAddrPTR(addr, sa, salen)
		return names, err, true
	}
	result := make(chan reverseLookupResult, 1)
	go cgoReverseLookup(result, addr, sa, salen)
	select {
	case r := <-result:
		return r.names, r.err, true
	case <-ctx.Done():
		return nil, mapErr(ctx.Err()), false
	}
}

func cgoLookupAddrPTR(addr string, sa * /*line :294:40*/_Ctype_struct_sockaddr /*line :294:57*/, salen  /*line :294:65*/_Ctype_socklen_t /*line :294:76*/) (names []string, err error) {
	acquireThread()
	defer releaseThread()

	var gerrno int
	var b []byte
	for l := nameinfoLen; l <= maxNameinfoLen; l *= 2 {
		b = make([]byte, l)
		gerrno, err = cgoNameinfoPTR(b, sa, salen)
		if gerrno == 0 || gerrno != ( /*line :303:31*/_Ciconst_EAI_OVERFLOW /*line :303:44*/) {
			break
		}
	}
	if gerrno != 0 {
		isTemporary := false
		switch gerrno {
		case ( /*line :310:8*/_Ciconst_EAI_SYSTEM /*line :310:19*/):
			if err == nil { // see golang.org/issue/6232
				err = syscall.EMFILE
			}
		default:
			err = addrinfoErrno(gerrno)
			isTemporary = addrinfoErrno(gerrno).Temporary()
		}
		return nil, &DNSError{Err: err.Error(), Name: addr, IsTemporary: isTemporary}
	}
	for i := 0; i < len(b); i++ {
		if b[i] == 0 {
			b = b[:i]
			break
		}
	}
	return []string{absDomainName(b)}, nil
}

func cgoReverseLookup(result chan<- reverseLookupResult, addr string, sa * /*line :329:75*/_Ctype_struct_sockaddr /*line :329:92*/, salen  /*line :329:100*/_Ctype_socklen_t /*line :329:111*/) {
	names, err := cgoLookupAddrPTR(addr, sa, salen)
	result <- reverseLookupResult{names, err}
}

func cgoSockaddr(ip IP, zone string) (* /*line :334:40*/_Ctype_struct_sockaddr /*line :334:57*/,  /*line :334:59*/_Ctype_socklen_t /*line :334:70*/) {
	if ip4 := ip.To4(); ip4 != nil {
		return cgoSockaddrInet4(ip4),  /*line :336:33*/_Ctype_socklen_t /*line :336:44*/(syscall.SizeofSockaddrInet4)
	}
	if ip6 := ip.To16(); ip6 != nil {
		return cgoSockaddrInet6(ip6, zoneCache.index(zone)),  /*line :339:56*/_Ctype_socklen_t /*line :339:67*/(syscall.SizeofSockaddrInet6)
	}
	return nil, 0
}

func copyIP(x IP) IP {
	if len(x) < 16 {
		return x.To16()
	}
	y := make(IP, len(x))
	copy(y, x)
	return y
}
